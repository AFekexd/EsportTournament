// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum Role {
  ADMIN
  ORGANIZER
  MODERATOR
  TEACHER
  STUDENT
}

enum TeamRole {
  CAPTAIN
  MEMBER
}

enum TournamentFormat {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
}

enum TournamentStatus {
  DRAFT
  REGISTRATION
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum BracketType {
  UPPER
  LOWER
  GRAND_FINAL
}

enum NotificationType {
  TOURNAMENT_INVITE
  TEAM_INVITE
  MATCH_SCHEDULED
  MATCH_RESULT
  SYSTEM
  BOOKING_CONFIRMED
  BOOKING_REMINDER
  BOOKING_CANCELLED
  WAITLIST_AVAILABLE
}

enum SeedingMethod {
  STANDARD
  SEQUENTIAL
  RANDOM
}

enum BugReportStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum BugReportCategory {
  WEBSITE
  TOURNAMENT
  BOOKING
  TEAM
  OTHER
}

enum BugReportPriority {
  LOW
  MEDIUM
  HIGH
}

// ============================================
// MODELS
// ============================================

// Felhasználó (Keycloak-ból szinkronizált adatok)
model User {
  id                 String    @id @default(uuid())
  keycloakId         String    @unique
  email              String    @unique
  username           String    @unique
  displayName        String?
  avatarUrl          String?
  omId               String?
  discordId          String?
  role               Role      @default(STUDENT)
  elo                Int       @default(1000)
  timeBalanceSeconds Int       @default(0) // Kiosk time balance
  // Granular email preferences
  emailNotifications   Boolean   @default(true) // Master toggle (legacy, kept for compatibility)
  emailPrefTournaments Boolean   @default(true) // Tournament announcements & invites
  emailPrefMatches     Boolean   @default(true) // Match reminders & results
  emailPrefBookings    Boolean   @default(true) // Booking confirmations & reminders
  emailPrefSystem      Boolean   @default(true) // System notifications
  emailPrefWeeklyDigest Boolean  @default(false) // Weekly summary emails (opt-in)
  // Discord DM preferences
  discordDmTournaments  Boolean   @default(true)  // Tournament announcements via DM
  discordDmMatches      Boolean   @default(true)  // Match reminders via DM
  discordDmReminders    Boolean   @default(true)  // General reminders via DM
  discordDmResults      Boolean   @default(true)  // Match results via DM
  discordDmSystem       Boolean   @default(false) // System notifications via DM (opt-in)
  steamId            String?
  steamAvatar        String?
  steamUrl           String?
  steamLevel         Int?
  steamPersonaname   String?
  steamCreatedAt     DateTime?
  perfectGamesCount  Int       @default(0)
  steamTotalGames    Int?
  steamTotalPlaytime Int?      // Total playtime in minutes
  steamRecentGames   Json?     // Array of recently played games [{appid, name, iconUrl, playtime2weeks}]
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  lastLogoutAt       DateTime? // For token invalidation

  teamMemberships      TeamMember[]
  ownedTeams           Team[]            @relation("TeamOwner")
  notifications        Notification[]
  gameStats            GameStats[]
  tournamentEntries    TournamentEntry[] // For solo tournament registration
  participatingEntries TournamentEntry[] @relation("TournamentParticipants") // For team tournament participation
  discordSettings      DiscordSettings?
  bookings             Booking[] // Computer bookings
  waitlistEntries      Waitlist[] // Waitlist entries
  // Match relations for solo tournaments
  homeMatches          Match[]           @relation("HomeUser")
  awayMatches          Match[]           @relation("AwayUser")
  wonMatches           Match[]           @relation("WinnerUser")

  // Kiosk relations
  sessions  Session[]
  logs      Log[]
  adminLogs Log[]     @relation("LogAdmin")

  ranks              UserRank[]
  changeRequests     ChangeRequest[]
  authoredChangelogs Changelog[]
  posts              NewsPost[]
  
  // Discord relations
  discordLogs        DiscordLog[]
  matchCheckIns      MatchCheckIn[]
  matchPredictions   MatchPrediction[]

  // Achievements (stored as JSON array)
  achievements       Json?  @default("[]") // Array of { id: string, unlockedAt: Date }

  // Favorite Game for Profile Cover
  favoriteGameId     String?
  favoriteGame       Game?    @relation("UserFavoriteGame", fields: [favoriteGameId], references: [id])
  
  // Terms of Service
  tosAcceptedAt      DateTime?
  
  // Bug Reports
  bugReports         BugReport[]
  bugReportNotification BugReportNotificationSetting? @relation("BugReportNotifications")
}

// Csapat
model Team {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  logoUrl     String?
  coverUrl    String?
  joinCode    String   @unique
  ownerId     String
  owner       User     @relation("TeamOwner", fields: [ownerId], references: [id])
  elo         Int      @default(1000)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members           TeamMember[]
  tournamentEntries TournamentEntry[]
  homeMatches       Match[]           @relation("HomeTeam")
  awayMatches       Match[]           @relation("AwayTeam")
  wonMatches        Match[]           @relation("WinnerTeam")
  
  // Scrim relations
  createdScrims     Scrim[]           @relation("ScrimRequester")
  acceptedScrims    Scrim[]           @relation("ScrimOpponent")
}

// Csapattag
model TeamMember {
  id       String   @id @default(uuid())
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId   String
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  role     TeamRole @default(MEMBER)
  joinedAt DateTime @default(now())

  @@unique([userId, teamId])
}

// Játék típus
model Game {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  imageUrl    String?
  rules       String?
  rulesPdfUrl String? // Base64 encoded PDF
  teamSize    Int? // 1, 2, 3, 5 (Optional, defaults to 1 if not set)
  createdAt   DateTime @default(now())

  tournaments Tournament[]
  gameStats   GameStats[]
  scrims      Scrim[]

  ranks     Rank[]
  userRanks UserRank[]
  favoritedBy User[] @relation("UserFavoriteGame")
}

// Verseny
model Tournament {
  id                   String           @id @default(uuid())
  name                 String
  description          String?
  imageUrl             String? // Custom tournament image
  streamUrl            String? // Twitch/YouTube stream URL
  gameId               String
  game                 Game             @relation(fields: [gameId], references: [id])
  format               TournamentFormat @default(SINGLE_ELIMINATION)
  status               TournamentStatus @default(DRAFT)
  teamSize             Int? // Override Game.teamSize (1=1v1, 5=5v5 etc.)
  maxTeams             Int
  startDate            DateTime
  endDate              DateTime?
  registrationDeadline DateTime
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Notification settings
  notifyUsers      Boolean @default(false) // Send in-app notifications
  notifyDiscord    Boolean @default(false) // Post to Discord
  discordChannelId String? @default("matches") // Which Discord channel to use
  discordRoleId    String? // Role specific to this tournament participants

  // Seeding settings
  seedingMethod SeedingMethod @default(STANDARD)

  // Qualifier settings
  hasQualifier       Boolean @default(false)
  qualifierMatches   Int     @default(0)
  qualifierMinPoints Int     @default(0)

  requireRank Boolean @default(true) // If true, all participants must have a rank for the game

  entries TournamentEntry[]
  matches Match[]
}

// Verseny jelentkezés
model TournamentEntry {
  id              String     @id @default(uuid())
  tournamentId    String
  tournament      Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  teamId          String? // Null for solo tournaments
  team            Team?      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId          String? // For solo tournaments (1v1)
  user            User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  seed            Int?
  matchesPlayed   Int        @default(0)
  qualifierPoints Int        @default(0)
  registeredAt    DateTime   @default(now())

  participants User[] @relation("TournamentParticipants")

  @@unique([tournamentId, teamId])
  @@unique([tournamentId, userId])
}

// Meccs
model Match {
  id           String      @id @default(uuid())
  tournamentId String
  tournament   Tournament  @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  round        Int
  position     Int
  bracketType  BracketType @default(UPPER)
  // Team references (for team tournaments)
  homeTeamId   String?
  homeTeam     Team?       @relation("HomeTeam", fields: [homeTeamId], references: [id])
  awayTeamId   String?
  awayTeam     Team?       @relation("AwayTeam", fields: [awayTeamId], references: [id])
  winnerId     String?
  winner       Team?       @relation("WinnerTeam", fields: [winnerId], references: [id])
  // User references (for solo/1v1 tournaments)
  homeUserId   String?
  homeUser     User?       @relation("HomeUser", fields: [homeUserId], references: [id])
  awayUserId   String?
  awayUser     User?       @relation("AwayUser", fields: [awayUserId], references: [id])
  winnerUserId String?
  winnerUser   User?       @relation("WinnerUser", fields: [winnerUserId], references: [id])
  // Scores and status
  homeScore       Int?
  awayScore       Int?
  status          MatchStatus @default(PENDING)
  scheduledAt     DateTime?
  playedAt        DateTime?
  checkInDeadline DateTime?   // Deadline for players to check in
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Check-in and prediction relations
  checkIns        MatchCheckIn[]
  predictions     MatchPrediction[]
}

// Játékos statisztikák
model GameStats {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameId    String
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  inGameId  String?
  stats     Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, gameId])
}

// Rangok
model Rank {
  id        String     @id @default(uuid())
  gameId    String
  game      Game       @relation(fields: [gameId], references: [id], onDelete: Cascade)
  name      String
  value     Int // P-ELO érték
  image     String?
  order     Int        @default(0)
  users     UserRank[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

// Felhasználói rangok
model UserRank {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  rankId     String
  rank       Rank     @relation(fields: [rankId], references: [id], onDelete: Cascade)
  gameId     String // Redundáns, de egyszerűsíti a query-t (User game rank-ja)
  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  assignedAt DateTime @default(now())

  @@unique([userId, gameId]) // Egy usernek egy játékban csak egy rangja lehet egyszerre
}

// Értesítések
model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
}

// Fun aktivitások (játéknapok, közös események)
model Event {
  id          String   @id @default(uuid())
  name        String
  description String?
  eventDate   DateTime
  location    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Discord notification settings
model DiscordSettings {
  id                      String   @id @default(uuid())
  userId                  String   @unique
  enabled                 Boolean  @default(false)
  webhookUrl              String?
  notifyOnTournamentStart Boolean  @default(true)
  notifyOnMatchScheduled  Boolean  @default(true)
  notifyOnMatchResult     Boolean  @default(true)
  notifyOnTeamInvite      Boolean  @default(true)
  notifyOnRoundComplete   Boolean  @default(true)
  mentionRole             String? // Discord role to mention (e.g., @everyone, role ID)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================
// BOOKING & KIOSK SYSTEM
// ============================================

enum ComputerStatus {
  AVAILABLE
  MAINTENANCE
  OUT_OF_ORDER
}

// Számítógép a teremben
model Computer {
  id       String  @id @default(uuid())
  name     String // "PC-1", "PC-2", stb.
  hostname String? @unique // Network hostname for Kiosk Client
  row      Int // 0 vagy 1 (2 sor)
  position Int // 0-4 (5 pozíció soronként)
  isActive Boolean @default(true) // Physically available

  // Kiosk-specific fields
  isLocked          Boolean @default(false)
  isCompetitionMode Boolean @default(false)

  status         ComputerStatus @default(AVAILABLE)
  specs          Json? // { cpu, gpu, ram, monitor, storage }
  installedGames String[] // Telepített játékok listája
  clientVersion  String? // The current version running on this machine (e.g. "1.0.0")
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  bookings        Booking[]
  waitlistEntries Waitlist[]
  sessions        Session[]
  logs            Log[]

  @@unique([row, position])
}

// Foglalás
model Booking {
  id           String    @id @default(uuid())
  computerId   String
  computer     Computer  @relation(fields: [computerId], references: [id], onDelete: Cascade)
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  date         DateTime  @db.Date // A foglalás napja
  startTime    DateTime // Kezdési időpont
  endTime      DateTime // Befejezési időpont (max 2 óra a startTime után)
  // QR kód bejelentkezés
  checkInCode  String?   @unique // QR kód tartalom
  checkedInAt  DateTime? // Bejelentkezés időpontja
  reminderSent Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([computerId, date])
  @@index([userId])
  @@index([date])
}

// Active Kiosk Session
model Session {
  id         String    @id @default(uuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id])
  computerId String
  computer   Computer  @relation(fields: [computerId], references: [id])
  startTime  DateTime  @default(now())
  endTime    DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
}

// Audit Logs for Kiosk/Admin actions
model Log {
  id         String    @id @default(uuid())
  type       String // LOGIN, LOGOUT, ADD_TIME, LOCK, UNLOCK
  message    String?
  metadata   Json? // Structured data for detailed view
  userId     String?
  user       User?     @relation(fields: [userId], references: [id])
  adminId    String?
  admin      User?     @relation("LogAdmin", fields: [adminId], references: [id])
  computerId String?
  computer   Computer? @relation(fields: [computerId], references: [id])
  createdAt  DateTime  @default(now())
}

// Várólistás rendszer
model Waitlist {
  id         String   @id @default(uuid())
  computerId String
  computer   Computer @relation(fields: [computerId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  date       DateTime @db.Date
  startHour  Int // 0-23
  endHour    Int // 0-23
  notified   Boolean  @default(false)
  createdAt  DateTime @default(now())

  @@unique([computerId, userId, date, startHour])
  @@index([computerId, date])
  @@index([userId])
}

// Admin preset az elérhető időpontokhoz
model BookingSchedule {
  id        String   @id @default(uuid())
  dayOfWeek Int // 0=Vasárnap, 1=Hétfő, ... 5=Péntek, 6=Szombat
  startHour Int // 0-23
  endHour   Int // 0-23
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Kiosk Client Version Management
model ClientVersion {
  id        String   @id @default(uuid())
  version   String   @unique // e.g., "1.0.1"
  fileData  Bytes // The binary content of the update ZIP
  isActive  Boolean  @default(false) // Only one version should be active (latest)
  createdAt DateTime @default(now())
}

// ============================================
// CHANGE REQUESTS
// ============================================

enum ChangeType {
  USER_PROFILE
  TEAM_PROFILE
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model ChangeRequest {
  id          String        @id @default(uuid())
  type        ChangeType
  entityId    String // ID of the User or Team
  requesterId String // User ID who made the request
  requester   User          @relation(fields: [requesterId], references: [id])
  data        Json // The requested changes (e.g. { name: "New", logoUrl: "..." })
  status      RequestStatus @default(PENDING)
  rejectionReason String?   // If REJECTED, why?
  adminNote       String?   // Internal notes
  processedById   String?   // Admin who processed it
  processedAt     DateTime? // When it was processed
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

// ============================================
// CHANGELOG & VERSIONING
// ============================================

enum ChangeLogType {
  MAJOR
  MINOR
  PATCH
}

model Changelog {
  id        String        @id @default(uuid())
  version   String        @unique // e.g., "1.0.0"
  type      ChangeLogType
  changes   String[] // List of change descriptions
  authorId  String
  author    User          @relation(fields: [authorId], references: [id])
  createdAt DateTime      @default(now())
}

// ============================================
// EMAIL LOGGING
// ============================================

enum EmailStatus {
  PENDING
  SENT
  FAILED
}

enum EmailType {
  TOURNAMENT_INVITE
  TOURNAMENT_ANNOUNCEMENT
  MATCH_REMINDER
  MATCH_RESULT
  BOOKING_CONFIRMATION
  BOOKING_REMINDER
  BOOKING_CANCELLED
  WAITLIST_AVAILABLE
  SYSTEM
  DIGEST
  ADMIN_BROADCAST
}

model EmailLog {
  id        String      @id @default(uuid())
  to        String
  subject   String
  type      EmailType
  status    EmailStatus @default(PENDING)
  attempts  Int         @default(1)
  error     String?
  metadata  Json?       // Extra info like tournamentId, bookingId, etc.
  createdAt DateTime    @default(now())
  sentAt    DateTime?

  @@index([to])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

// ============================================
// DISCORD LOGGING & FEATURES
// ============================================

enum DiscordLogType {
  TOURNAMENT_ANNOUNCE
  MATCH_REMINDER
  MATCH_RESULT
  SYSTEM_ANNOUNCE
  CHECK_IN_REQUEST
  REGISTRATION_REMINDER
  WEEKLY_STANDINGS
  ACHIEVEMENT
  PREDICTION
  DM_NOTIFICATION
  COMMAND_USAGE
  ERROR
}

enum DiscordLogStatus {
  SENT
  FAILED
  PENDING
}

// Discord message/notification log
model DiscordLog {
  id          String           @id @default(uuid())
  type        DiscordLogType
  channelId   String?
  messageId   String?
  userId      String?          // Our internal user ID
  discordId   String?          // Discord user ID
  content     String?          @db.Text
  embedTitle  String?
  status      DiscordLogStatus @default(SENT)
  error       String?
  metadata    Json?
  createdAt   DateTime         @default(now())

  user        User?            @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([type])
  @@index([createdAt])
  @@index([userId])
  @@index([status])
}

// Match check-in system
model MatchCheckIn {
  id        String   @id @default(uuid())
  matchId   String
  userId    String
  teamId    String?  // If team match, which team
  checkedAt DateTime @default(now())
  
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([matchId])
}

// Match predictions for engagement
model MatchPrediction {
  id                  String   @id @default(uuid())
  matchId             String
  predictorId         String
  predictedWinnerId   String?  // Team or User ID of predicted winner
  predictedHomeScore  Int?
  predictedAwayScore  Int?
  points              Int      @default(0)  // Points earned for correct prediction
  isCorrect           Boolean? // Set after match completes
  createdAt           DateTime @default(now())
  
  match       Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  predictor   User     @relation(fields: [predictorId], references: [id], onDelete: Cascade)

  @@unique([matchId, predictorId])
  @@index([matchId])
  @@index([predictorId])
  @@index([isCorrect])
}

// ============================================
// SCRIM FINDER
// ============================================

enum ScrimStatus {
  OPEN
  ACCEPTED
  CANCELLED
}

model Scrim {
  id              String      @id @default(uuid())
  requesterTeamId String
  requesterTeam   Team        @relation("ScrimRequester", fields: [requesterTeamId], references: [id], onDelete: Cascade)
  
  gameId          String
  game            Game        @relation(fields: [gameId], references: [id])
  
  opponentTeamId  String?
  opponentTeam    Team?       @relation("ScrimOpponent", fields: [opponentTeamId], references: [id])
  
  scheduledAt     DateTime
  durationMinutes Int         @default(60)
  notes           String?
  status          ScrimStatus @default(OPEN)
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([gameId])
  @@index([scheduledAt])
  @@index([status])
  @@map("Scrims")
}

// ============================================
// NEWS & BLOG
// ============================================

model NewsPost {
  id          String   @id @default(uuid())
  title       String
  slug        String   @unique
  content     String   @db.Text
  excerpt     String?  @db.Text
  coverImage  String?
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([isPublished])
  @@index([createdAt])
}

// ============================================
// BUG REPORTS
// ============================================

model BugReport {
  id          String              @id @default(uuid())
  title       String
  description String              @db.Text
  category    BugReportCategory
  priority    BugReportPriority   @default(MEDIUM)
  status      BugReportStatus     @default(PENDING)
  imageUrl    String?
  
  reporterId  String
  reporter    User                @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  
  adminNote   String?             @db.Text
  resolvedAt  DateTime?
  
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([status])
  @@index([reporterId])
  @@index([createdAt])
}

// Bug Report Notification Settings (which admins get notified)
model BugReportNotificationSetting {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation("BugReportNotifications", fields: [userId], references: [id], onDelete: Cascade)
  receiveEmail    Boolean  @default(true)
  receiveDiscord  Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
